\documentclass[book]{jlreq}

\usepackage[colorlinks=true]{hyperref}

\usepackage{amsmath}

\title{実用プログラミング言語 Labda}
\author{Hexirp}
\date{\today}

\newcommand{\p}[1]{ \mathord{ \left( #1 \right) } }
\renewcommand{\b}[1]{ \mathord{ \left[ #1 \right] } }
\renewcommand{\c}[1]{ \mathord{ \left\{ #1 \right\} } }
\renewcommand{\a}[1]{ \mathord{ \left\langle #1 \right\rangle } }

\begin{document}

\maketitle

\chapter*{序文}

ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。

\chapter{型なしラムダ計算}

型なしラムダ計算は、関数のみを持つ計算モデルであり、チューリング完全である。

\section{関数}

関数とは何なのだろうか？ 2023 年現在の中学校学習指導要領は、まず最初に「 \( y \) は \( x \) の関数である」とは「 \( x \) の値が定まれば \( y \) の値が定まる」であると定義している。

たとえば、 \( 2 x \) は \( x \) の関数である。 \( x \) の値が \( 4 \) だと定まれば \( 2 x \) の値も \( 8 \) だと定まるからである。もう一つの例として、普通の感覚に反しているかもしれないが、 \( 100 \) は \( x \) の関数である。 \( x \) の値が \( 3 \) だと定まれば \( 100 \) の値は \( 100 \) だと定まるからである。さらにもう一つの例として、 \( 2 x \) は \( 4 x \) の関数である。 \( 4 x \) の値が \( 4 \) だと定まれば \( 2 x \) の値は \( 2 \) だと定まるからである。

それまで当然のものとして見なしてきたものを、新しく研究の対象とすることで、数学を先に進めることが出来る。関数も同様である。 \( y \) が \( x \) の関数である時に、その関数そのものを \( f \) と表すことにする。 \( x \) の値が \( a \) である時の \( y \) の値を \( f \p{ a } \) と表すことにする。このとき、 \( y = f \p{ x } \) が成り立つ。

ある関数 \( f \) を定義したい時は、「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」と書けばよい。紛れがない時は、「任意の \( x \) に対して」を省略して、単に \( f \p{ x } = x + 2 \) とだけ書いてもよいものとする。

この記法には、いくつかの利点がある。一つ目に、 \( x \) の値が \( a \) である時の \( y \) の値を数式の中で使いたい時に、 \( f \p{ a } \) というように簡単に書き表し、数式の中で使うことができるようになった。二つ目に、一度定義した関数を簡単に使い回せるようになり、古い関数を使って新しい関数を定義することが簡単になり、複数の箇所で同じ関数を利用することが簡単になった。三つ目に、未知の関数を取り扱えるようになり、高階関数を考察できるようになり、具体的に書き下す手段がない関数も想定できるようになった。

\section{ラムダ記法}

前述の記法を導入することで関数を変数として扱うことができるようになった。しかし、その関数を定義する時は「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」としか書けない。これでは、高階関数を関数に適用する時に、わざわざ関数を定義する必要が出てくる。それを回避するために、ラムダ記法を導入する。

このラムダ記法は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つ関数を、 \( \lambda x \ldotp \p{ x + 2 } \) と書くというものである。このような式をラムダ抽象あるいは無名関数と呼ぶ。

ラムダ抽象は変数の名前が変わっても等しくなければならない。たとえば、 \( \lambda x \ldotp \p{ x^3 + x + 1 } \) と \( \lambda y \ldotp \p{ y^3 + y + 1 } \) は等しいものでなければならない。これは、ラムダ抽象を含む式について、何らかの操作を考えるとき、この関係を保たなければならないということも意味する。これに従ってラムダ抽象を含む式を書き換えることを \( \_ \rightarrow_\alpha \_ \) で書く。ついでに、ラムダ抽象を含む式を適用で書き換えることを \( \_ \rightarrow_\beta \_ \) で書く。

\( \lambda x \ldotp \lambda y \ldotp \p{ x + y } \) を \( y \) に適用することを考えよう。単純に考えれば、 \( \p{ \lambda x \ldotp \lambda y \ldotp \p{ x + y } } \p{ y } \rightarrow_\beta \p{ \lambda y \ldotp \p{ y + y } } \) になるが、これが正しいとすると、 \( \p{ \lambda x \ldotp \lambda y \ldotp \p{ x + y } } \p{ y } \rightarrow_\alpha \p{ \lambda x \ldotp \lambda z \ldotp \p{ x + z } } \p{ y } \rightarrow_\beta \p{ \lambda z \ldotp \p{ y + z } } \) と矛盾する。この場合、明らかに後者が正しいものである。このことから、ラムダ抽象を適用する際は、変数の名前を変えなければ正しい結果にならないことがあるということが分かる。

\( \_ \rightarrow_\alpha \_ \) をアルファ変換と呼ぶ。 \( \_ \rightarrow_\beta \_ \) をベータ変換あるいはベータ簡約と呼ぶ。これで、ラムダ計算を定義するのに必要な概念が出揃った。

\section{ラムダ計算}

ここからは面倒を避けるために \( f \p{ x } \) を \( f \cdot x \) と表記することにする。

ラムダ計算の前項 (pre-term) を、次のように定義する。

\begin{enumerate}
    \item \( x \) を変数とすると、 \( x \) は前項である。
    \item \( x \) を変数として、 \( T \) を前項であるとすると、 \( \lambda x \ldotp T \) は前項である。
    \item \( T \) を仮項でして、 \( S \) を前項であるとすると、 \( T \cdot S \) は前項である。
\end{enumerate}

「 \( x \) は \( T \) の変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の変数である。
    \item \( x \) は \( \lambda x \ldotp T \) の変数である。
    \item \( x \) が \( T \) の変数であれば、 \( x \) は \( \lambda y \ldotp T \) の変数である。
    \item \( x \) が \( T \) の変数であれば、 \( x \) は \( T \cdot S \) の変数である。
    \item \( x \) が \( S \) の変数であれば、 \( x \) は \( T \cdot S \) の変数である。
\end{enumerate}

「 \( x \) は \( T \) の自由変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の自由変数である。
    \item \( x \) は \( \lambda x \ldotp T \) の自由変数ではない。
    \item \( x \) が \( T \) の自由変数であれば、 \( x \) は \( \lambda y \ldotp T \) の自由変数である。
    \item \( x \) が \( T \) の自由変数であれば、 \( x \) は \( T \cdot S \) の自由変数である。
    \item \( x \) が \( S \) の自由変数であれば、 \( x \) は \( T \cdot S \) の自由変数である。
\end{enumerate}

「 \( x \) は \( T \) の束縛変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の束縛変数ではない。
    \item \( x \) は \( \lambda x \ldotp T \) の束縛変数である。
    \item \( x \) が \( T \) の束縛変数であれば、 \( x \) は \( \lambda y \ldotp T \) の束縛変数である。
    \item \( x \) が \( T \) の束縛変数であれば、 \( x \) は \( T \cdot S \) の束縛変数である。
    \item \( x \) が \( S \) の束縛変数であれば、 \( x \) は \( T \cdot S \) の束縛変数である。
\end{enumerate}

\end{document}
