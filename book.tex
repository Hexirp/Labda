\documentclass[book]{jlreq}

\usepackage[colorlinks=true]{hyperref}

\usepackage{amsmath}

\title{実用プログラミング言語 Labda}
\author{Hexirp}
\date{\today}

\newcommand{\p}[1]{ \mathord{ \left( #1 \right) } }
\renewcommand{\b}[1]{ \mathord{ \left[ #1 \right] } }
\renewcommand{\c}[1]{ \mathord{ \left\{ #1 \right\} } }
\renewcommand{\a}[1]{ \mathord{ \left\langle #1 \right\rangle } }

\begin{document}

\maketitle

\chapter*{序文}

ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。ここは序文である。

\chapter{型なしラムダ計算}

型なしラムダ計算は、関数のみを持つ計算モデルであり、チューリング完全である。

\section{関数}

関数とは何なのだろうか？ 2023 年現在の中学校学習指導要領は、まず最初に「 \( y \) は \( x \) の関数である」とは「 \( x \) の値が定まれば \( y \) の値が定まる」であると定義している。

たとえば、 \( 2 x \) は \( x \) の関数である。 \( x \) の値が \( 4 \) だと定まれば \( 2 x \) の値も \( 8 \) だと定まるからである。もう一つの例として、普通の感覚に反しているかもしれないが、 \( 100 \) は \( x \) の関数である。 \( x \) の値が \( 3 \) だと定まれば \( 100 \) の値は \( 100 \) だと定まるからである。

それまで当然のものとして見なしてきたものを、新しく研究の対象とすることで、数学を先に進めることが出来る。関数も同様である。 \( y \) が \( x \) の関数である時に、その関数そのものを \( f \) と表すことにする。 \( x \) の値が \( a \) である時の \( y \) の値を \( f \p{ a } \) と表すことにする。このとき、 \( y = f \p{ x } \) が成り立つ。

ある関数 \( f \) を定義したい時は、「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」と書けばよい。紛れがない時は、「任意の \( x \) に対して」を省略して、単に \( f \p{ x } = x + 2 \) とだけ書いてもよいものとする。

この記法には、いくつかの利点がある。一つ目に、 \( x \) の値が \( a \) である時の \( y \) の値を数式の中で使いたい時に、 \( f \p{ a } \) というように簡単に書き表し、数式の中で使うことができるようになった。二つ目に、一度定義した関数を簡単に使い回せるようになり、古い関数を使って新しい関数を定義することが簡単になり、複数の箇所で同じ関数を利用することが簡単になった。三つ目に、未知の関数を取り扱えるようになり、高階関数を考察できるようになり、具体的に書き下す手段がない関数も想定できるようになった。

\section{ラムダ記法}

前述の記法を導入することで関数を変数として扱うことができるようになった。しかし、その関数を定義する時は「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」としか書けない。これでは、高階関数を関数に適用する時に、わざわざ関数を定義する必要が出てくる。それを回避するために、ラムダ記法を導入する。

たとえば、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つ関数を、 \( \lambda x \ldotp \p{ x + 2 } \) と書く。

\end{document}
