\documentclass[book]{jlreq}

\usepackage[colorlinks=true]{hyperref}

\usepackage{amsmath}

\title{実用プログラミング言語 Labda}
\author{Hexirp}
\date{\today}

\newcommand{\p}[1]{ \mathord{ \left( #1 \right) } }
\renewcommand{\b}[1]{ \mathord{ \left[ #1 \right] } }
\renewcommand{\c}[1]{ \mathord{ \left\{ #1 \right\} } }
\renewcommand{\a}[1]{ \mathord{ \left\langle #1 \right\rangle } }

\begin{document}

\maketitle

\chapter*{序文}

ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。

\chapter{型なしラムダ計算}

ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。ここはプレースホルダ―である。

\section{関数}

関数とは何なのだろうか？ 2023 年現在の中学校学習指導要領は、まず最初に「 \( y \) は \( x \) の関数である」とは「 \( x \) の値が定まれば \( y \) の値が定まる」であると定義している。

たとえば、 \( 2 x \) は \( x \) の関数である。 \( x \) の値が \( 4 \) だと定まれば \( 2 x \) の値も \( 8 \) だと定まるからである。もう一つの例として、普通の感覚に反しているかもしれないが、 \( 100 \) は \( x \) の関数である。 \( x \) の値が \( 3 \) だと定まれば \( 100 \) の値は \( 100 \) だと定まるからである。さらにもう一つの例として、 \( 2 x \) は \( 4 x \) の関数である。 \( 4 x \) の値が \( 4 \) だと定まれば \( 2 x \) の値は \( 2 \) だと定まるからである。

それまで影のものとして見なしてきたものを、新しく研究の対象とすることで、数学を先に進めることが出来る。関数も同様である。 \( y \) が \( x \) の関数である時に、その関数そのものを \( f \) と表すことにする。 \( x \) の値が \( a \) である時の \( y \) の値を \( f \p{ a } \) と表すことにする。このとき、 \( y = f \p{ x } \) が成り立つ。

ある関数 \( f \) を定義したい時は、「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」と書けばよい。紛れがない時は、「任意の \( x \) に対して」を省略して、単に \( f \p{ x } = x + 2 \) とだけ書いてもよいものとする。

この記法には、いくつかの利点がある。一つ目に、 \( x \) の値が \( a \) である時の \( y \) の値を数式の中で使いたい時に、 \( f \p{ a } \) というように簡単に書き表し、数式の中で使うことができるようになった。二つ目に、一度定義した関数を簡単に使い回せるようになり、古い関数を使って新しい関数を定義することが簡単になり、複数の箇所で同じ関数を利用することが簡単になった。三つ目に、未知の関数を取り扱えるようになり、高階関数を考察できるようになり、具体的に書き下す手段がない関数も想定できるようになった。

\section{ラムダ記法}

前述の記法を導入することで関数を変数として扱うことができるようになった。しかし、その関数を定義する時は「関数 \( f \) は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つものとする」としか書けない。これでは、高階関数を関数に適用する時に、わざわざ関数を定義する必要が出てくる。それを回避するために、ラムダ記法を導入する。

このラムダ記法は、任意の \( x \) に対して \( f \p{ x } = x + 2 \) が成り立つ関数を、 \( \lambda x \ldotp \p{ x + 2 } \) と書くというものである。このような式をラムダ抽象あるいは無名関数と呼ぶ。

ラムダ抽象は変数の名前が変わっても等しくなければならない。たとえば、 \( \lambda x \ldotp \p{ x^3 + x + 1 } \) と \( \lambda y \ldotp \p{ y^3 + y + 1 } \) は等しいものでなければならない。これは、ラムダ抽象を含む式について、何らかの操作を考えるとき、この関係を保たなければならないということも意味する。これに従ってラムダ抽象を含む式を書き換えることをアルファ変換と呼んで \( \_ \rightarrow_\alpha \_ \) で書く。

ラムダ抽象 \( \lambda x \ldotp t \) の \( x \) を \( a \) で置き換えたものは \( \p{ \lambda x \ldotp t } \p{ a } \) と等しくなければならない。これに従ってラムダ抽象を含む式を書き換えることをベータ簡約と呼んで \( \_ \rightarrow_\beta \_ \) で書く。

アルファ変換とベータ簡約は衝突することがある。この時はアルファ変換を優先しなければならない。 \( \lambda x \ldotp \lambda y \ldotp \p{ x + y } \) を \( y \) に適用することを考えよう。単純に考えれば、 \( \p{ \lambda x \ldotp \lambda y \ldotp \p{ x + y } } \p{ y } \rightarrow_\beta \p{ \lambda y \ldotp \p{ y + y } } \) になるが、これが正しいとすると、 \( \p{ \lambda x \ldotp \lambda y \ldotp \p{ x + y } } \p{ y } \rightarrow_\alpha \p{ \lambda x \ldotp \lambda z \ldotp \p{ x + z } } \p{ y } \rightarrow_\beta \p{ \lambda z \ldotp \p{ y + z } } \) と矛盾する。この場合、明らかに後者が正しいものである。このことから、ラムダ抽象を適用する際は、変数の名前を変えなければ正しい結果にならないことがあるということが分かる。

\section{ラムダ計算}

ラムダ計算の変数 (variable) を \( \hat{x}, \hat{y}, \hat{z}, \ldots \) のように書くことにする。ラムダ計算の前項 (pre-term) を、次のように定義する。

\begin{enumerate}
    \item \( \hat{x} \) を変数とすると、 \( \hat{x} \) は前項である。
    \item \( \hat{x} \) を変数として、 \( t \) を前項であるとすると、 \( \lambda \p{ \hat{x}, t } \) は前項である。
    \item \( t \) を前項として、 \( s \) を前項であるとすると、 \( \mathrm{A} \p{ t, s } \) は前項である。
\end{enumerate}

たとえば、 \( \lambda x \ldotp \lambda y \ldotp x \) は \( \lambda \p{ \hat{x}, \lambda \p{ \hat{y}, \hat{x} } } \) である。

「 \( \hat{x} \) は \( t \) の変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の変数である。
    \item \( x \) は \( \lambda x \ldotp T \) の変数である。
    \item \( x \) が \( T \) の変数であれば、 \( x \) は \( \lambda y \ldotp T \) の変数である。
    \item \( x \) が \( T \) の変数であれば、 \( x \) は \( T \cdot S \) の変数である。
    \item \( x \) が \( S \) の変数であれば、 \( x \) は \( T \cdot S \) の変数である。
\end{enumerate}

「 \( x \) は \( T \) の自由変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の自由変数である。
    \item \( x \) は \( \lambda x \ldotp T \) の自由変数ではない。
    \item \( x \) が \( T \) の自由変数であれば、 \( x \) は \( \lambda y \ldotp T \) の自由変数である。
    \item \( x \) が \( T \) の自由変数であれば、 \( x \) は \( T \cdot S \) の自由変数である。
    \item \( x \) が \( S \) の自由変数であれば、 \( x \) は \( T \cdot S \) の自由変数である。
\end{enumerate}

「 \( x \) は \( T \) の束縛変数である」を次のように定義する。

\begin{enumerate}
    \item \( x \) は \( x \) の束縛変数ではない。
    \item \( x \) は \( \lambda x \ldotp T \) の束縛変数である。
    \item \( x \) が \( T \) の束縛変数であれば、 \( x \) は \( \lambda y \ldotp T \) の束縛変数である。
    \item \( x \) が \( T \) の束縛変数であれば、 \( x \) は \( T \cdot S \) の束縛変数である。
    \item \( x \) が \( S \) の束縛変数であれば、 \( x \) は \( T \cdot S \) の束縛変数である。
\end{enumerate}

\end{document}
